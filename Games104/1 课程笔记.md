# 架构分层

<img src="file:///D:/CGNote/Games104/img/architecture%20layers.png" title="" alt="1" data-align="center">

自顶向下：

1. 工具层：（编辑器

2. 功能层：让游戏世界动起来（UI、动画、物理、脚本）的直接来源

3. 资源层：组成游戏世界的数据（模型、音频）的处理（加载、管理），支持功能层

4. 核心层：底层操作（内存分配、线程池、容器、数学计算）

5. 平台层：处理平台差异（不同平台的计算机制细节可能不一样）

然后还有第三方成熟的针对特定问题的解决方案集成在各个层次

特征：

- 底层为上层提供支撑

- 上层不知道底层的实现方式

- 上层可以调用下层提供的功能，但是下层不允许调用上层的

- 从头构建引擎的时候不总是从最底下开始开发，通常从核心层

实践推动认知，为一个引擎添加一个功能（例如人跑动），恰恰是要把代码分块装入各个层的相关模块。越往上越灵活，越往下越稳定。考虑好把功能如何分解，并合理安排在各个层次是很重要的事情

## 工具层

工具层并非是Runtime的，但是依旧很重要。

- 以Level Editor为中心展开的一系列编辑器

- 不以运行效率为优先考量的

- 创造力的直接支撑（目的是去让别人更快捷方便地使用引擎）

- DCC软件也属于工具层

## 资源层

resource -> asset：外部多种资源<mark>预处理</mark>转换为<mark>内建格式</mark>用以<mark>高效</mark>处理和<mark>唯一标识</mark>（GUID）便于查找

使用Resource Manager统一管理各类资源，我们要关注：

- 生命周期（不同的资产又不同的生命周期）

- 内存占用（内存是有限的，需要在合适的时机加载与卸载资源）

- GC与延迟加载

## 功能层

### Tick

<img title="" src="file:///D:/CGNote/Games104/img/EngineTick.png" alt="1" data-align="center" width="719">

- Tick Logic：先更新逻辑部分（根据输入和物理把游戏世界更新

- Tick Render：根据上面的结构更新渲染（显示）

### Other

- 充分利用多核CPU

## 核心层

- 数学库（Trick、SIMD）

- 适用于引擎的容器（减少内存碎片、提升访问效率）

- 内存管理：
  
  - 把数据放一起
  
  - 顺序读取数据
  
  - 按块分配与归还

## 平台层

- 不同平台文件系统不一样

- IO逻辑和权限也不太一样

- 图形API不一样

使用RHI(Render Hardware Interface)：

- 为不同的GPU和图形SDK提供统一的操作（平台无关性）

- 为特定平台执行优化

- 解决不同硬件架构的运行差异（PlayStation：PPU/SPU）

# 游戏世界构成

- 动态物

- 静态物

- 地形系统

- TOD（Time of the day）

- 植被（似乎是静态，但是也有动画，而且量大）

- Trigger Box

抽象出来就是GameObject，当然地形可能不是GO

>  GameObject：Property+Behavior

组件化编程：解决多继承的问题

Object Based Tick：

- 按System/Component进行Tick：先Tick一类，再Tick另一类

- Event System：通过事件机制来为GO之间交互解耦

但即使有了Event System机制，但是实际情况是复杂的：

- 开发者会定义很多新的类型，也需要注册参与事件收发：开放闭合原则

- 巨量GO先后顺序：By Unique ID、By Position

$n^2$挑战：n个物体最坏的情况要和$n-1$个物体传递消息，其数量级是$n^2$，如果有一万个物体，最坏的情况就是一亿。

# 思考

因为我是游戏开发从业者，我更应该思考的是“设计”思路：

- 引擎的模块划分是如何与以常见的业务对应上的、如何设计的足够通用的

- 各个模块之间是如何联系起来并运转的

- 各个模块和功能有哪些成熟的解决方案
