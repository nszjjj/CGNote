#hotfix
# Intro

例行放一下别人的基础概念讲解的博客：[Zhihu - 从零开始讲解HybirdCLR 热更](https://zhuanlan.zhihu.com/p/685026219)

结合上面的博客，大致理解如下基础概念：

HybridCLR 的提出是去解决原先 IL2CPP 的局限性的，那就得先知道 IL2CPP 解决了什么问题。而 IL2CPP 的设计初衷又是去解决 mono 的局限性的，它通过牺牲动态性（如热更新），换取更高的性能和跨平台合规性。

mono 的本质是在不同平台上通过虚拟机运行或编译 IL（Intermediate Language）代码，mono 有两种运行方式：JIT 和解释执行，其中解释比 JIT 还慢 5~10 倍。此外在跨平台方面，Mono 有几个平台就得移植几个 VM，包括 JIT 编译器、GC、线程管理、异常处理等内容。但是每个平台差异显著，其系统调用、内存管理、线程模型不尽相同，所以新增一个平台的适配工作量巨大。

而 IL2CPP 经过 AOT，所有代码在构建阶段已编译为机器码，运行时直接执行，无额外编译或解释开销。其好处是显而易见地：

- 减少了运行时的开销
- CPP 语言本身执行速度就有优势
- C++ 编译器（如 Clang、MSVC）能对代码进行内联、循环展开、指令重排等深度优化

另一方面虽然 IL2CPP 也得在各个平台准备运行时，但是它用了一种类似于引擎渲染提到的 RHI 层的概念。我们知道 RHI 层做了这么一件事：

- 上层（游戏引擎）：调用统一的 RHI 接口（如 `DrawMesh`）
- 中间层（RHI 抽象）：将通用指令转换为具体 GPU API 调用（如 DX12/Vulkan）
- 底层（平台实现）：各 GPU 厂商的驱动处理硬件差异

而 IL2CPP 也采取了类似的设计思想，将大部分逻辑做成了平台无关的，把跨平台的关键工作交给了各个平台成熟 C++ 编译器（如 Clang/MSVC/GCC）生成最终机器码：

- 上层（C# 代码）：统一的 C# 逻辑（如 GC、反射）
- 中间层（libil2cpp 核心）：提供跨平台的运行时服务（如类型系统、异常处理）
- 底层（平台适配层）：通过 HAL 封装线程、文件系统等平台相关操作

运行时（libil2cpp）涵盖了中间层（平台无关层）和底层（平台适配层）两部分，其中大部分代码位于平台无关层，少量代码位于平台适配层，针对新平台需要做的适配工作主要集中在平台适配层，较之 mono 的移植工作，其工作量已极大减少

> Write once, compile anywhere 即 WOCA 是一种编程理念/设计哲学

这样看来似乎 IL2CPP 已臻完美，但是其 AOT 的工作方式并不是毫无缺点的。它需要更多的打包时间，同时 AOT 的编译方式会导致代码“固化”，因此无法在运行时加载新的 C# 代码。就其原理来看，

为什么