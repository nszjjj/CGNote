# 基本的RayTracing要理清的概念

## 大体步骤

1. 生成射线

2. 求交

3. 着色

生成射线就是相机位置沿每个像素方向发射射线，对于每个射线要和场景中的物体求交。

在产生交点的情况下要对该点着色，记录每个光源对这个点最终颜色的贡献，大致公式如下：

$$
Color =f(pos, normal, lightDir, viewDir)
$$

对于环境光，会退化成更加简单的形式：因为环境光是四面八方的，所以光源方向或者视角方向不会有影响。

当然这只是基础版本，所以考虑的不多。在更高级的着色模型下还会考虑间接光照等效果。

# 细节

## Ray方向确定

- 根据FOV和焦距推导（显然很不直观）

- 相机坐标到成像面（划分为网格）单个网格中心向量

显然使用后者会更简洁

## 求交

分两种

1. 对SDF求交，作为数学模型按数学公式推导即可

2. 同网格体求交，本质是同三角面求交（光线与构成网格的所有三角形分别进行求交测试，然后找出距离光线起点最近的交点）

>  一个模型有很多个三角面，而场景往往不止一个模型，特别是很多模型可能和光线方向差异巨大，因此会结合加速结构（BVH或者KD树等），根据空间信息提前取消掉对某个模型内的所有三角面的求交测试。

### SDF求交

我觉得这个可以待会再补充

### 三角面求交：莫勒-特伦伯算法

## 着色

> 即光线命中物体的位置如何对最终颜色做出贡献

一个点的颜色是直接或者间接受光源影响的，故需保存光源信息。而不同光源对像素颜色的作用方式又不尽相同：

1. 点光源

2. 方向光（平行光）

3. 环境光

### 对阴影部分的着色

1. 硬阴影

2. 软阴影

3. 半透明体积的阴影

> 从摄像机发出光线称为 primary ray ，而从交点向光源发出的光线为shadow ray

不管是硬阴影还是软阴影还是半透明体积的阴影，都存在 shadow ray 的概念。

不同的是，硬阴影只需要一条，软阴影会发射多条查看命中率。半透明体积的阴影则需要考虑介质的密度、散射和吸收特性造成的衰减，此时就类似RayMarching体积渲染的技术概念了。

# 代码思路

由于光线能和SDF或者实际的模型求交（虽然求交思路不太一样），所以需要一个接口（抽象类）描述场景中的每个物体，并且实现求交功能（以及方便后面加速结构管理）

对于实际的Mesh求交，实际上就是和所有三角面进行三角面求交，并返回距离最短的那个（注意法线和光线方向，不要把背面搞进来）

在获取到交点之后，需要计算
